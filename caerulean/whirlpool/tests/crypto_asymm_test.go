package tests

import (
	"bytes"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/binary"
	"main/crypto"
	"testing"
)

const RSA_MESSAGE_LENGTH = 1024

func TestMarshallingRSAKey(test *testing.T) {
	test.Logf("RSA public key generated: %v", crypto.RSA_NODE_KEY.PublicKey)

	publicBytes, err := x509.MarshalPKIXPublicKey(&(crypto.RSA_NODE_KEY.PublicKey))
	if err != nil {
		test.Fatalf("error marshalling public key: %v", err)
	}
	test.Logf("RSA public key marshalled: %v", publicBytes)

	publicKey, err := crypto.ParsePublicKey(publicBytes)
	if err != nil {
		test.Fatalf("error unmarshalling public key: %v", err)
	}
	test.Logf("RSA public key ungenerated: %v", publicKey)
}

func TestRSACycle(test *testing.T) {
	message := make([]byte, RSA_MESSAGE_LENGTH)
	err := binary.Read(rand.Reader, binary.BigEndian, &message)
	if err != nil {
		test.Fatalf("error generating random bytes: %v", err)
	}
	test.Logf("bytes generated: %v", message)

	_, err = rsa.EncryptOAEP(sha256.New(), rand.Reader, &crypto.RSA_NODE_KEY.PublicKey, message, nil)
	if err == nil {
		test.Fatalf("generated bytes can be encrypted with regular RSA: %v", err)
	}
	test.Log("bytes can not be encrypted with regular RSA")

	ciphertext, err := crypto.EncodeRSA(message, nil, &crypto.RSA_NODE_KEY.PublicKey)
	if err != nil {
		test.Fatalf("error encoding message: %v", err)
	}
	test.Logf("bytes encrypted: %v", ciphertext)

	plaintext, err := crypto.DecodeRSA(ciphertext, false, crypto.RSA_NODE_KEY)
	if err != nil {
		test.Fatalf("error decoding message: %v", err)
	}
	test.Logf("bytes decrypted: %v", plaintext)

	if !bytes.Equal(message, plaintext) {
		test.Fatalf("encoded bytes (%v) don't match decoded bytes (%v)", message, plaintext)
	}
}
